package parser

import (
	"encoding/xml"
	"fmt"
	"log"
	"net/http"

	"golang.org/x/net/html/charset"
)

// Parse xml
func Parse() {
	// Open our xmlFile
	// xmlFile, err := os.Open("/Users/adarshpandey/Projects/SyncifyMe/NewsAPI/src/parser/liveupdates.xml")
	// if we os.Open returns an error then handle it
	// if err != nil {
	// fmt.Println(err)
	// }

	// fmt.Println("Successfully Opened users.xml")
	// // defer the closing of our xmlFile so that we can parse it later on
	// defer xmlFile.Close()

	// // read our opened xmlFile as a byte array.
	// byteValue, _ := ioutil.ReadAll(xmlFile)

	// // we initialize our Users array
	// var autoGenerated AutoGenerated
	// // we unmarshal our byteArray which contains our
	// // xmlFiles content into 'users' which we defined above
	// // xml.Unmarshal(byteValue, &autoGenerated)

	// reader := bytes.NewReader(byteValue)

	var autoGenerated AutoGenerated
	url := "http://news.rediff.com/commentary/2018/apr/14/liveupdates.xml"
	// Build the request
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Fatal("NewRequest: ", err)
		return
	}

	// For control over HTTP client headers,
	// redirect policy, and other settings,
	// create a Client
	// A Client is an HTTP client
	client := &http.Client{}

	// Send the request via a client
	// Do sends an HTTP request and
	// returns an HTTP response
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal("Do: ", err)
		return
	}

	// Callers should close resp.Body
	// when done reading from it
	// Defer the closing of the body
	defer resp.Body.Close()

	decoder := xml.NewDecoder(resp.Body)
	decoder.CharsetReader = charset.NewReaderLabel
	err = decoder.Decode(&autoGenerated)

	// we iterate through every user within our users array and
	// print out the user Type, their name, and their facebook url
	// as just an example
	for i := 0; i < len(autoGenerated.COMMENTRIES.COMMENTRY); i++ {
		fmt.Println("Desc: " + DecodeBase64(SpaceMap(autoGenerated.COMMENTRIES.COMMENTRY[i].DESC)))
	}

}
